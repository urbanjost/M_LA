program try_matz
use M_matrix, only : mat88, mat88_get, mat88_put
integer,parameter :: lda=10
integer           :: m,n, i,j
doubleprecision   :: arr(lda,lda),x(lda,lda)
   call mat88(-1,' ') ! iquiet initialization of  mat88().
   call mat88( 2,'b=<1 2 3 4; 5 6 7 8>') ! create some values in mat88(3f)
   call mat88( 2,'a=magic(4)') ! create some values in mat88(3f)
   call mat88( 2,'c=3**3') ! create some values in mat88(3f)
   !call mat88( 2,'debug(1)') 
   ! The matrix ARR is generated by the program 
   m = 6
   n = 6
   arr = 0
   do j = 1, n
      do i = 1, n
         arr(i,j) = iabs(i-j)
      enddo   
   enddo   
   RUN: block
!      ! The matrix ARR and sent to the stack by the first call to mat_MATZ.
!      call mat_matz(arr,lda,n,n,'A',1,ierr)
!      if (ierr .ne. 0) exit run
!      ! The call to mat88(1,'X=inv(A)') will invert our matrix, put the result
!      ! X on the stack and go back to our program.
!      call mat88(1,'X=inv(A)')
!      call mat88(1,'A')
      call mat88(2,'who')
      ! The second call to mat_MATZ will retrieve X .
      call mat88_get(x,lda,m,n,'a',0,ierr)
      if (ierr .ne. 0) write(*,*)'<ERROR>',ierr
      call mat88_get(x,lda,m,n,'b',0,ierr)
      if (ierr .ne. 0) write(*,*)'<ERROR>',ierr
      call mat88_get(x,lda,m,n,'c',0,ierr)
      if (ierr .ne. 0) write(*,*)'<ERROR>',ierr
      call mat88_get(x,lda,m,n,'unknown',0,ierr)
      if (ierr .ne. 0) write(*,*)'<ERROR>',ierr
      ! The next call to mat88() will place you in interactive mode in mat88().
      ! Entering "return" will return back to the main program.
      call mat88(1,' ')
   endblock RUN
   ! By the way, this matrix X is interesting. Take a look at round(2*(n-1)*X).
end program try_matz
